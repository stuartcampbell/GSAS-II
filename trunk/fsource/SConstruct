import platform
import sys
import os
import glob
import subprocess
#==========================================================================================
def which_path(program):
    "emulates Unix which: finds a program in path, but returns the path"
    import os, sys
    def is_exe(fpath):
        return os.path.exists(fpath) and os.access(fpath, os.X_OK)
    if sys.platform == "win32" and os.path.splitext(program)[1].lower() != '.exe':
        program = program + '.exe'
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return fpath
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return path
    return ""
#==========================================================================================
# misc initializations
F2PYflags = '' # compiler options for f2py command
F2PYpath = which_path('f2py')       # default path to f2py & python
FORTpath = which_path('gfortran')   # default path to compiler
ENVvars = {}
SCONSvars = {}
liblist = []
#==========================================================================================
# configure platform dependent options here: 
if sys.platform == "win32":
    F2PYsuffix = '.pyd'
    FORTpath = which_path('g77')   # default path to compiler
    F2PYflags = '--compiler=mingw32 --fcompiler=gnu'
    SCONSvars['FORTRANFLAGS'] = ' -w -O2 -fno-automatic -finit-local-zero -malign-double -mwindows'
elif sys.platform == "darwin":
    ENVvars['LDFLAGS'] = '-undefined dynamic_lookup -bundle -static-libgfortran -static-libgcc'
    F2PYflags = '--fcompiler=gnu95 --f77exec=gfortran --f77flags="-fno-range-check"'
    #F2PYpath = '/Library/Frameworks/Python.framework/Versions/6.2/bin/'     # path to f2py (python 6.2)
    #F2PYpath = '/Library/Frameworks/Python.framework/Versions/current/bin/' # path to f2py
    #FORTpath = '/sw/bin'                                                    # path to compilier
    F2PYsuffix = '.so'
elif sys.platform == "linux2":
    #ENVvars['LDFLAGS'] = '-undefined dynamic_lookup -bundle -static-libgfortran -static-libgcc'
    #F2PYflags = '--fcompiler=gnu95 --f77exec=gfortran --f77flags="-fno-range-check"'
    F2PYsuffix = '.so'
else:
    print "Sorry, parameters for platform "+sys.platform+" are not yet defined"
    sys.exit()
#==========================================================================================
# override from command-line options
for var in ['F2PYflags','F2PYpath','FORTpath','F2PYsuffix']:
    if ARGUMENTS.get(var, None) is not None:
        print 'Setting',var,'to',ARGUMENTS.get(var),'based on command line'
        exec(var + "= ARGUMENTS.get('" + var +"')")
var = 'LDFLAGS'
if ARGUMENTS.get(var, None) is not None:
    print 'Setting '+var+' environment variable to',ARGUMENTS.get(var),'based on command line'
    ENVvars[var] = ARGUMENTS.get(var)
var = 'FORTRANFLAGS'
if ARGUMENTS.get(var, None) is not None:
    print 'Setting '+var+' internal variable to',ARGUMENTS.get(var),'based on command line'
    SCONSvars[var] = ARGUMENTS.get(var)
#==========================================================================================

# get the python version number from the python image in the f2py directory
p = subprocess.Popen([os.path.join(F2PYpath,'python')], stdout=subprocess.PIPE, stdin=subprocess.PIPE)
p.stdin.write("import sys;print str(sys.version_info[0]);print str(sys.version_info[1]);sys.exit()")
p.stdin.close()
p.wait()
versions = p.stdout.readlines()
version = str(int(versions[0])) + '.' + str(int(versions[1]))
#

# Install location
InstallLoc = '../bin'
if len(COMMAND_LINE_TARGETS) == 0:
    Default(InstallLoc)
elif 'install' in COMMAND_LINE_TARGETS:
    if platform.architecture()[0] == '64bit':
        bits = '64'
    else:
        bits = ''
    if sys.platform == "win32":
        prefix = 'binwin'
    elif sys.platform == "darwin":
        prefix = 'binmac'
    elif sys.platform == "linux2":
        prefix = 'binlinux'
    InstallLoc = '../' + prefix + bits + version
    Alias('install',InstallLoc)
if 'help' in COMMAND_LINE_TARGETS:
    print """
Building Fortran routines for use with GSAS-II
----------------------------------------------

To build the compiled modules files needed to run GSAS-II, invoke this script:
    scons [options]
where the following options are defined (all are optional):

-Q      -- produces less output from scons

-n      -- causes scons to show but not execute the commands it will perform

-c      -- clean: causes scons to delete previously created files (don't use
   with install)

help    -- causes this message to be displayed (no compiling is done)

install -- causes the module files to be placed in an installation directory
   (../bin<X>NNv.v) rather than ../bin (<X> is mac, win or linux; NN is 64
   or blank; v.v is the python version (2.6 or 2.7,...). Normally used only
   by Brian or Bob for distribution of compiled software.

The following options override defaults set in the scons script:

F2PYflags='string' -- defines optional flags to be supplied to f2py:
   Typically these option define which fortran compiler to use.

F2PYpath=<path>    -- define a path to the f2py program; default is to use
   first f2py found in path

FORTpath=<path>    -- define a path to the f2py program; default is to use
   first gfortran (g77 for Windows) found in path

F2PYsuffix='.xxx'  -- extension for output module files (default: win: '.pyd',
   mac/linux: '.so')

LDFLAGS='string'   -- string of options to be used for f2py during link step

FORTRANFLAGS='string'  -- string of options to be used for Fortran
   during library build step

Note that at present, only 32-bit python is supported and python 3.x is
not supported.

examples:
    scons -Q
       (builds into ../bin for current platform using default options)
    scons -Q install
       (builds into ../bin<platform> for module distribution)
    scons -Q install F2PYpath=/Library/Frameworks/Python.framework/Versions/6.2/bin/
       (builds with a non-default [e.g. older] version of python)
    """
    sys.exit()

# commands needed to run f2py 
def generate_f2py(source, target, env, for_signature):
    module = os.path.splitext(str(source[0]))[0]
    if len(liblist) > 0:
        for lib in liblist:
            module = module + ' ' + str(lib)
    return os.path.join(F2PYpath,'f2py')  + ' -c $SOURCE -m ' + module + ' ' + F2PYflags
f2py = Builder(generator = generate_f2py)
env = Environment(BUILDERS = {'f2py' : f2py},)
# Setup build Environment
if FORTpath != "":  env.PrependENVPath('PATH', FORTpath)
#for path in PATH: 
#    env.PrependENVPath('PATH', path)
for var in ENVvars:
    env['ENV'][var] = ENVvars[var]
for var in SCONSvars:
    env[var] = ENVvars[var]

# for testing
#out = env.f2py('fellipse.for')
#filename = str(out[0])
#print filename
#print os.path.join(InstallLoc,filename)
#Command(os.path.join(InstallLoc,filename),filename,Copy("$TARGET","$SOURCE"))


# find libraries to build (subdirectories named *subs)
for sub in glob.glob('*subs'):
    lib = Library(sub, Glob(os.path.join(sub,'*.for'))) # register library to be created
    liblist.append(lib[0].name)
    filename = str(lib[0])
    #Install(InstallLoc,filename)
# find modules that need to be built
modlist = []
for src in glob.glob('*.for'):
    target = os.path.splitext(src)[0] + '.so'
    out = env.f2py(target,src)
    Depends(target, liblist) # make sure libraries are rebuilt if old
    modlist.append(out[0].name)
    env.Install(InstallLoc, out[0].name)
print 80*'='
for var in ['F2PYflags','F2PYpath','FORTpath','F2PYsuffix']:
    print 'Variable ',var,'is',eval(var)
print 'Required fortran libraries:',
for lib in liblist: print " " + lib,
print ""
print 'f2py modules:',
for mod in modlist: print " " + mod,
print ""
print 'Python/f2py version =',version
print 'Install directory is',InstallLoc
print 80*'='
