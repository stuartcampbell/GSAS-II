

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>GSASIImapvars &mdash; GSAS-II 0.2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="GSAS-II 0.2.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">GSAS-II 0.2.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for GSASIImapvars</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">########### SVN repository information ###################</span>
<span class="c"># $Date: 2013-08-29 14:47:35 -0500 (Thu, 29 Aug 2013) $</span>
<span class="c"># $Author: vondreele $</span>
<span class="c"># $Revision: 1046 $</span>
<span class="c"># $URL: https://subversion.xray.aps.anl.gov/pyGSAS/trunk/GSASIImapvars.py $</span>
<span class="c"># $Id: GSASIImapvars.py 1046 2013-08-29 19:47:35Z vondreele $</span>
<span class="c">########### SVN repository information ###################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">*GSASIImapvars: Parameter constraints*</span>
<span class="sd">======================================</span>

<span class="sd">Module to implements algebraic contraints, parameter redefinition</span>
<span class="sd">and parameter simplification contraints.</span>

<span class="sd">Parameter redefinition (new vars) is done by creating one or more relationships</span>
<span class="sd">between a set of parameters</span>

<span class="sd">::</span>

<span class="sd">   Mx1 * Px + My1 * Py +...</span>
<span class="sd">   Mx2 * Px + Mz2 * Pz + ...</span>

<span class="sd">where Pj is a parameter name and Mjk is a constant.</span>

<span class="sd">Constant constraint Relations can also be supplied in the form of an equation:</span>

<span class="sd">::</span>

<span class="sd">  nx1 * Px + ny1 * Py +... = C1</span>

<span class="sd">where Cn is a constant. These equations define an algebraic</span>
<span class="sd">constrant.</span>

<span class="sd">Parameters can also be &quot;fixed&quot; (held), which prevents them from being refined.</span>

<span class="sd">All of the above three cases are input using routines</span>
<span class="sd">GroupConstraints and GenerateConstraints. The input consists of a list of</span>
<span class="sd">relationship dictionaries:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    constrDict = [</span>
<span class="sd">         {&#39;0:12:Scale&#39;: 2.0, &#39;0:14:Scale&#39;: 4.0, &#39;0:13:Scale&#39;: 3.0, &#39;0:0:Scale&#39;: 0.5},</span>
<span class="sd">         {&#39;2::C(10,6,1)&#39;: 1.0, &#39;1::C(10,6,1)&#39;: 1.0},</span>
<span class="sd">         {&#39;0::A0&#39;: 0.0}]</span>
<span class="sd">    fixedList = [&#39;5.0&#39;, None, &#39;0&#39;]</span>

<span class="sd">Where the dictionary defines the first part of an expression and the corresponding fixedList</span>
<span class="sd">item is either None (for parameter redefinition) or the constant value, for a constant</span>
<span class="sd">constraint equation. A dictionary that contains a single term defines a variable that</span>
<span class="sd">will be fixed (held). The multiplier and the fixedList value in this case are ignored.</span>

<span class="sd">Parameters can also be equivalenced or &quot;slaved&quot; to another parameter, such that one</span>
<span class="sd">(independent) parameter is equated to several (now dependent) parameters. In</span>
<span class="sd">algebraic form this is:</span>

<span class="sd">::</span>

<span class="sd">   P0 = M1 * P1 = M2 * P2 = ...</span>

<span class="sd">Thus parameters P0, P1 and P2,... are linearly equivalent. Routine StoreEquivalence is</span>
<span class="sd">used to specify these equivalences.</span>

<span class="sd">Parameter redefinition (new vars) describes a new, independent, parameter, which</span>
<span class="sd">is defined in terms of dependent parameters that are defined in the</span>
<span class="sd">Model, while fixed constrained relations effectively reduce the complexity</span>
<span class="sd">of the Model by removing a degree of freedom. It is possible for a parameter to appear</span>
<span class="sd">in both a parameter redefinition expression and a fixed constraint equation, but a</span>
<span class="sd">parameter cannot be used a parameter equivalance cannot be used elsewhere (not fixed,</span>
<span class="sd">constrained or redefined). Likewise a fixed parameter cannot be used elsewhere (not</span>
<span class="sd">equivalanced, constrained or redefined).</span>

<span class="sd">Relationships are grouped so that a set of dependent parameters appear</span>
<span class="sd">in only one group (done in routine GroupConstraints.) Note that if a</span>
<span class="sd">group contains relationships/equations that involve N dependent</span>
<span class="sd">parameters, there must exist N-C new parameters, where C is the number</span>
<span class="sd">of contraint equations in the group. Routine GenerateConstraints takes</span>
<span class="sd">the output from GroupConstraints and generates the</span>
<span class="sd">&quot;missing&quot; relationships and saves that information in the module&#39;s</span>
<span class="sd">global variables. Each generated parameter is named sequentially using paramPrefix.</span>

<span class="sd">A list of parameters that will be varied is specified as input to GenerateConstraints</span>
<span class="sd">(varyList). A fixed parameter will simply be removed from this list preventing that</span>
<span class="sd">parameter from being varied. Note that all parameters in a relationship must specified as</span>
<span class="sd">varied (appear in varyList) or none can be varied. This is checked in GenerateConstraints</span>
<span class="sd">(as well as for generated relationships in SetVaryFlags).</span>

<span class="sd">* If all parameters in a parameter redefinition (new var) relationship are varied, the</span>
<span class="sd">  parameter assigned to this expression (::constr:n, see paramPrefix) newly generated</span>
<span class="sd">  parameter is varied. Note that any generated &quot;missing&quot; relations are not varied. Only</span>
<span class="sd">  the input relations are varied.</span>
<span class="sd">  </span>
<span class="sd">* If all parameters in a fixed constraint equation are varied, the generated &quot;missing&quot;</span>
<span class="sd">  relations in the group are all varied. This provides the N-C degrees of freedom. </span>

<span class="sd">*External Routines*</span>
<span class="sd">-------------------</span>

<span class="sd">To define a set of constrained and unconstrained relations, one</span>
<span class="sd">defines a list of dictionary defining constraint parameters and their</span>
<span class="sd">values, a list of fixed values for each constraint and a list of</span>
<span class="sd">parameters to be varied. In addition, one uses</span>
<span class="sd">:func:`StoreEquivalence` to define parameters that are equivalent. One</span>
<span class="sd">can then use :func:`CheckConstraints` to check that the input is</span>
<span class="sd">internally consistent and finally :func:`GroupConstraints` and</span>
<span class="sd">:func:`GenerateConstraints` to generate the internally used</span>
<span class="sd">tables. Routines :func:`Map2Dict` is used to initialize the parameter</span>
<span class="sd">dictionary and :func:`Dict2Map`, :func:`Dict2Deriv`, and</span>
<span class="sd">:func:`ComputeDepESD` are used to apply constraints. Routine</span>
<span class="sd">:func:`VarRemapShow` is used to print out the constraint information,</span>
<span class="sd">as stored by :func:`GenerateConstraints`.</span>

<span class="sd">:func:`InitVars`</span>
<span class="sd">  This is optionally used to clear out all defined previously defined constraint information</span>
<span class="sd">  </span>
<span class="sd">:func:`StoreEquivalence`</span>
<span class="sd">  To implement parameter redefinition, one calls StoreEquivalence. This should be called for every set of</span>
<span class="sd">  equivalence relationships. There is no harm in using StoreEquivalence with the same independent variable:</span>

<span class="sd">  .. code-block:: python</span>

<span class="sd">       StoreEquivalence(&#39;x&#39;,(&#39;y&#39;,))</span>
<span class="sd">       StoreEquivalence(&#39;x&#39;,(&#39;z&#39;,))</span>

<span class="sd">  or equivalently </span>

<span class="sd">  .. code-block:: python</span>

<span class="sd">       StoreEquivalence(&#39;x&#39;,(&#39;y&#39;,&#39;z&#39;))</span>

<span class="sd">  The latter will run more efficiently. Note that mixing independent and dependent variables is</span>
<span class="sd">  problematic. This is not allowed:</span>

<span class="sd">  .. code-block:: python</span>

<span class="sd">        StoreEquivalence(&#39;x&#39;,(&#39;y&#39;,))</span>
<span class="sd">        StoreEquivalence(&#39;y&#39;,(&#39;z&#39;,))</span>
<span class="sd">        </span>
<span class="sd">  Use StoreEquivalence before calling GenerateConstraints or CheckConstraints</span>

<span class="sd">:func:`CheckConstraints`</span>
<span class="sd">   To check that input in internally consistent, use CheckConstraints</span>

<span class="sd">:func:`Map2Dict`</span>
<span class="sd">   To determine values for the parameters created in this module, one</span>
<span class="sd">   calls Map2Dict. This will not apply contraints.</span>

<span class="sd">:func:`Dict2Map`</span>
<span class="sd">   To take values from the new independent parameters and constraints,</span>
<span class="sd">   one calls Dict2Map. This will apply contraints.</span>

<span class="sd">:func:`Dict2Deriv`</span>
<span class="sd">   Use Dict2Deriv to determine derivatives on independent parameters</span>
<span class="sd">   from those on dependent ones</span>

<span class="sd">:func:`ComputeDepESD`      </span>
<span class="sd">   Use ComputeDepESD to compute uncertainties on dependent variables</span>

<span class="sd">:func:`VarRemapShow`</span>
<span class="sd">   To show a summary of the parameter remapping, one calls VarRemapShow</span>

<span class="sd">*Global Variables*</span>
<span class="sd">------------------</span>

<span class="sd">dependentParmList:</span>
<span class="sd">   contains a list by group of lists of</span>
<span class="sd">   parameters used in the group. Note that parameters listed in</span>
<span class="sd">   dependentParmList should not be refined as they will not affect</span>
<span class="sd">   the model</span>

<span class="sd">indParmList:</span>
<span class="sd">     a list of groups of Independent parameters defined in</span>
<span class="sd">     each group. This contains both parameters used in parameter</span>
<span class="sd">     redefinitions as well as names of generated new parameters.</span>

<span class="sd">fixedVarList:</span>
<span class="sd">     a list of variables that have been &#39;fixed&#39;</span>
<span class="sd">     by defining them as equal to a constant (::var: = 0). Note that</span>
<span class="sd">     the constant value is ignored at present. These variables are</span>
<span class="sd">     later removed from varyList which prevents them from being refined. </span>
<span class="sd">     Unlikely to be used externally.</span>

<span class="sd">arrayList:</span>
<span class="sd">     a list by group of relationship matrices to relate</span>
<span class="sd">     parameters in dependentParmList to those in indParmList. Unlikely</span>
<span class="sd">     to be used externally.</span>

<span class="sd">invarrayList:</span>
<span class="sd">     a list by group of relationship matrices to relate</span>
<span class="sd">     parameters in indParmList to those in dependentParmList. Unlikely</span>
<span class="sd">     to be used externally.</span>

<span class="sd">fixedDict:</span>
<span class="sd">     a dictionary containing the fixed values corresponding</span>
<span class="sd">     to parameter equations.  The dict key is an ascii string, but the</span>
<span class="sd">     dict value is a float.  Unlikely to be used externally.</span>

<span class="sd">*Routines*</span>
<span class="sd">----------</span>

<span class="sd">Note that parameter names in GSAS-II are strings of form ``&lt;ph&gt;:&lt;hst&gt;:&lt;nam&gt;``</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">GSASIIpath</span>
<span class="n">GSASIIpath</span><span class="o">.</span><span class="n">SetVersionNumber</span><span class="p">(</span><span class="s">&quot;$Revision: 1046 $&quot;</span><span class="p">)</span>
<span class="c"># data used for constraints; </span>
<span class="n">debug</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># turns on printing as constraint input is processed</span>
<span class="c"># note that constraints are stored listed by contraint groups, where each constraint</span>
<span class="c"># group contains those parameters that must be handled together</span>
<span class="n">dependentParmList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># contains a list of parameters in each group</span>
<span class="c"># note that parameters listed in dependentParmList should not be refined </span>
<span class="n">arrayList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># a list of of relationship matrices </span>
<span class="n">invarrayList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># a list of inverse relationship matrices </span>
<span class="n">indParmList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># a list of names for the new parameters</span>
<span class="n">fixedDict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># a dictionary containing the fixed values corresponding to defined parameter equations</span>
               <span class="c"># key is original ascii string, value is float</span>
<span class="n">fixedVarList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># List of variables that should not be refined</span>

<span class="c"># prefix for parameter names</span>
<span class="n">paramPrefix</span> <span class="o">=</span> <span class="s">&quot;::constr:&quot;</span>
<span class="n">consNum</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># number of the next constraint to be created</span>

<div class="viewcode-block" id="InitVars"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.InitVars">[docs]</a><span class="k">def</span> <span class="nf">InitVars</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;Initializes all constraint information&#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">fixedDict</span><span class="p">,</span><span class="n">consNum</span>
    <span class="n">dependentParmList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># contains a list of parameters in each group</span>
    <span class="n">arrayList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># a list of of relationship matrices </span>
    <span class="n">invarrayList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># a list of inverse relationship matrices </span>
    <span class="n">indParmList</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># a list of names for the new parameters</span>
    <span class="n">fixedDict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># a dictionary containing the fixed values corresponding to defined parameter equations</span>
    <span class="n">consNum</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># number of the next constraint to be created</span>
    <span class="n">fixedVarList</span> <span class="o">=</span> <span class="p">[]</span>
</div>
<div class="viewcode-block" id="GroupConstraints"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.GroupConstraints">[docs]</a><span class="k">def</span> <span class="nf">GroupConstraints</span><span class="p">(</span><span class="n">constrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;divide the constraints into groups that share no parameters.</span>

<span class="sd">    :param dict constrDict: a list of dicts defining relationships/constraints</span>

<span class="sd">    ::</span>
<span class="sd">    </span>
<span class="sd">       constrDict = [{&lt;constr1&gt;}, {&lt;constr2&gt;}, ...]</span>

<span class="sd">    where {&lt;constr1&gt;} is {&#39;param1&#39;: mult1, &#39;param2&#39;: mult2,...}</span>

<span class="sd">    :returns: two lists of lists:</span>
<span class="sd">    </span>
<span class="sd">      * a list of grouped contraints where each constraint grouped containts a list of indices for constraint constrDict entries</span>
<span class="sd">      * a list containing lists of parameter names contained in each group</span>
<span class="sd">      </span>
<span class="sd">      &quot;&quot;&quot;</span>
    <span class="n">assignedlist</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># relationships that have been used</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># contains a list of grouplists</span>
    <span class="n">ParmList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">consi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">constrDict</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">assignedlist</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># already in a group, skip</span>
        <span class="c"># starting a new group</span>
        <span class="n">grouplist</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,]</span>
        <span class="n">assignedlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">groupset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">consi</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># always loop at least once</span>
        <span class="k">while</span><span class="p">(</span><span class="n">changes</span><span class="p">):</span> <span class="c"># loop until we can&#39;t find anything to add to the current group</span>
            <span class="n">changes</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># but don&#39;t loop again unless we find something</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">consj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">constrDict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">assignedlist</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># already in a group, skip</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">consj</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&amp;</span> <span class="n">groupset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># true if this needs to be added</span>
                    <span class="n">changes</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">grouplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">assignedlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">groupset</span> <span class="o">=</span> <span class="n">groupset</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">consj</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grouplist</span><span class="p">)</span>
        <span class="n">varlist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">groupset</span><span class="p">))</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">ParmList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">groups</span><span class="p">,</span><span class="n">ParmList</span>
</div>
<div class="viewcode-block" id="CheckConstraints"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.CheckConstraints">[docs]</a><span class="k">def</span> <span class="nf">CheckConstraints</span><span class="p">(</span><span class="n">varyList</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">fixedList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Takes a list of relationship entries comprising a group of</span>
<span class="sd">    constraints and checks for inconsistencies such as conflicts in</span>
<span class="sd">    parameter/variable definitions and or inconsistently varied parameters.</span>

<span class="sd">    :param list varyList: a list of parameters names that will be varied</span>

<span class="sd">    :param dict constrDict: a list of dicts defining relationships/constraints (as defined in :func:`GroupConstraints`)</span>

<span class="sd">    :param list fixedList: a list of values specifying a fixed value for each dict in constrDict. Values are</span>
<span class="sd">      either strings that can be converted to floats or None if the constraint defines a new parameter rather</span>
<span class="sd">      than a constant.</span>

<span class="sd">    :returns: two strings: </span>

<span class="sd">      * the first lists conflicts internal to the specified constraints</span>
<span class="sd">      * the second lists conflicts where the varyList specifies some</span>
<span class="sd">        parameters in a constraint, but not all</span>
<span class="sd">        </span>
<span class="sd">      If there are no errors, both strings will be empty</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">consNum</span>
    <span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="n">warnmsg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="n">fixVlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># process fixed (held) variables</span>
    <span class="k">for</span> <span class="n">cdict</span> <span class="ow">in</span> <span class="n">constrDict</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fixVlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c"># process equivalences: make a list of dependent and independent vars</span>
    <span class="c">#    and check for repeated uses (repetition of a parameter as an</span>
    <span class="c">#    independent var is OK)</span>
    <span class="n">indepVarList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">depVarList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">multdepVarList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">multarr</span><span class="p">,</span><span class="n">invmultarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">multarr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># an equivalence</span>
            <span class="n">zeromult</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">mapvars</span><span class="p">:</span>
                <span class="n">varied</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">notvaried</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                    <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                    <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">mv</span>
                <span class="k">if</span> <span class="n">mv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indepVarList</span><span class="p">:</span> <span class="n">indepVarList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span><span class="n">invmultarr</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">zeromult</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                        <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                        <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">v</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">depVarList</span><span class="p">:</span>
                        <span class="n">multdepVarList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">depVarList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">varied</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Not all variables refined in equivalence:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varlist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot; &amp; &quot;</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>            
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; =&gt; &quot;</span> <span class="o">+</span> <span class="n">s</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Not refined: &#39;</span> <span class="o">+</span> <span class="n">notvaried</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="k">if</span> <span class="n">zeromult</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Zero multiplier is invalid in equivalence:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varlist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot; &amp; &quot;</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>            
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; =&gt; &quot;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

    <span class="c"># check for errors:</span>
    <span class="n">inboth</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">indepVarList</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">depVarList</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inboth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">The following parameters(s) are used as both dependent and independent variables in Equivalence relations:</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inboth</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot;, &quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multdepVarList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">The following parameters(s) are used in multiple Equivalence relations as dependent variables:</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">multdepVarList</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot;, &quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>            
        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">equivVarList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indepVarList</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">depVarList</span><span class="p">)))</span>
    <span class="c">#print &#39;equivVarList&#39;,equivVarList</span>
    <span class="n">inboth</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fixVlist</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">equivVarList</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inboth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">The following parameter(s) are used in both Equivalence and Fixed constraints:</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inboth</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot;, &quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

    <span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span> <span class="o">=</span> <span class="n">GroupConstraints</span><span class="p">(</span><span class="n">constrDict</span><span class="p">)</span>
    <span class="c"># scan through parameters in each relationship. Are all varied? If only some are</span>
    <span class="c"># varied, create a warning message.</span>
    <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">varlist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">VaryFree</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
            <span class="n">varied</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">notvaried</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                    <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                    <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">var</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fixVlist</span><span class="p">:</span>
                    <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Parameter &#39;</span><span class="o">+</span><span class="n">var</span><span class="o">+</span><span class="s">&quot; is Fixed and used in a constraint:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                    <span class="n">errmsg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">if</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">varied</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">]):</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Not all variables refined in constraint:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Not refined: &#39;</span> <span class="o">+</span> <span class="n">notvaried</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">if</span> <span class="n">errmsg</span> <span class="ow">or</span> <span class="n">warnmsg</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">errmsg</span><span class="p">,</span><span class="n">warnmsg</span>

    <span class="c"># now look for process each group and create the relations that are needed to form</span>
    <span class="c"># non-singular square matrix</span>
    <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">varlist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># a constraint group with a single variable can be ignored</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">):</span> <span class="c"># too many relationships -- no can do</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Over-constrained input. &quot;</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;There are more constraints &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">than variables &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">multarr</span> <span class="o">=</span> <span class="n">_FillArray</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">varlist</span><span class="p">)</span>
            <span class="n">_RowEchelon</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span><span class="n">multarr</span><span class="p">,</span><span class="n">varlist</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Singular input. &quot;</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;There are internal inconsistencies in these constraints</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">multarr</span> <span class="o">=</span> <span class="n">_FillArray</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">varlist</span><span class="p">,</span><span class="n">FillDiagonals</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">GramSchmidtOrtho</span><span class="p">(</span><span class="n">multarr</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Unexpected singularity with constraints (in Gram-Schmidt)</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">continue</span>
        <span class="n">mapvar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="p">[:]</span>
        <span class="c"># scan through all generated and input variables</span>
        <span class="c"># Check again for inconsistent variable use</span>
        <span class="c"># for new variables -- where varied and unvaried parameters get grouped</span>
        <span class="c"># together. I don&#39;t think this can happen when not flagged before, but</span>
        <span class="c"># it does not hurt to check again. </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)):</span>
            <span class="n">varied</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">notvaried</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">fixedval</span> <span class="o">=</span> <span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                        <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                        <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">var</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixedval</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">fixedval</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="n">paramPrefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">consNum</span><span class="p">)</span>
                <span class="n">mapvar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
                <span class="n">consNum</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">VaryFree</span> <span class="ow">or</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">varyList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mapvar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fixedval</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">notvaried</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Not all variables refined in generated constraint&quot;</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Please report this unexpected error</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">warnmsg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span>
                    <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="n">warnmsg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n\t</span><span class="s">Not refined: &#39;</span> <span class="o">+</span> <span class="n">notvaried</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">multarr</span><span class="p">)</span>            
        <span class="k">except</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Singular input. &quot;</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;The following constraints are not &quot;</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;linearly independent</span><span class="se">\n\t</span><span class="s">or do not &quot;</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;allow for generation of a non-singular set</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&#39;Please report this unexpected error</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="k">return</span> <span class="n">errmsg</span><span class="p">,</span><span class="n">warnmsg</span>
</div>
<div class="viewcode-block" id="GenerateConstraints"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.GenerateConstraints">[docs]</a><span class="k">def</span> <span class="nf">GenerateConstraints</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span><span class="p">,</span><span class="n">varyList</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">fixedList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Takes a list of relationship entries comprising a group of</span>
<span class="sd">    constraints and builds the relationship lists and their inverse</span>
<span class="sd">    and stores them in global variables Also checks for internal</span>
<span class="sd">    conflicts or inconsistencies in parameter/variable definitions.</span>

<span class="sd">    :param list groups: a list of grouped contraints where each constraint grouped containts a list of</span>
<span class="sd">      indices for constraint constrDict entries, created in :func:`GroupConstraints` (returned as 1st value)</span>

<span class="sd">    :param list parmlist: a list containing lists of parameter names contained in each group,</span>
<span class="sd">      created in :func:`GroupConstraints` (returned as 1st value)</span>

<span class="sd">    :param list varyList: a list of parameters names (strings of form ``&lt;ph&gt;:&lt;hst&gt;:&lt;nam&gt;``) that will be varied</span>
<span class="sd">    </span>
<span class="sd">    :param dict constrDict: a list of dicts defining relationships/constraints (as defined in :func:`GroupConstraints`)</span>

<span class="sd">    :param list fixedList: a list of values specifying a fixed value for each dict in constrDict. Values are</span>
<span class="sd">      either strings that can be converted to floats, float values or None if the constraint defines a new</span>
<span class="sd">      parameter</span>
<span class="sd">      </span>
<span class="sd">    :param dict constrDict: a list of dicts defining relationships/constraints</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">consNum</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

    <span class="c"># process fixed (held) variables</span>
    <span class="k">for</span> <span class="n">cdict</span> <span class="ow">in</span> <span class="n">constrDict</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fixedVarList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c"># process equivalences: make a list of dependent and independent vars</span>
    <span class="c">#    and check for repeated uses (repetition of a parameter as an</span>
    <span class="c">#    independent var is OK)</span>
    <span class="n">indepVarList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">depVarList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">multdepVarList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">multarr</span><span class="p">,</span><span class="n">invmultarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">multarr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">zeromult</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">mapvars</span><span class="p">:</span>
                <span class="c">#s = &#39;&#39;</span>
                <span class="n">varied</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">notvaried</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                    <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                    <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">mv</span>
                <span class="k">if</span> <span class="n">mv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indepVarList</span><span class="p">:</span> <span class="n">indepVarList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span><span class="n">invmultarr</span><span class="p">):</span>
                    <span class="c">#if len(s): s += &#39;  &amp; &#39;</span>
                    <span class="c">#s += str(v)</span>
                    <span class="c">#if m != 1:</span>
                    <span class="c">#    s += &quot; / &quot; + str(m[0])                        </span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">zeromult</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                        <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                        <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">v</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">depVarList</span><span class="p">:</span>
                        <span class="n">multdepVarList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">depVarList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c">#print str(mv) + &#39; is equivalent to parameter(s): &#39;+s</span>
            <span class="k">if</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">varied</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Not all variables refined in equivalence:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varlist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot; &amp; &quot;</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>            
                <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; =&gt; &quot;</span> <span class="o">+</span> <span class="n">s</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Not refined: &#39;</span> <span class="o">+</span> <span class="n">notvaried</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="k">if</span> <span class="n">zeromult</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Zero multiplier is invalid in equivalence:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varlist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot; &amp; &quot;</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>            
                <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; =&gt; &quot;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

    <span class="c">#print &#39;indepVarList&#39;,indepVarList</span>
    <span class="c">#print &#39;depVarList&#39;,depVarList</span>
    <span class="c"># check for errors:</span>
    <span class="n">inboth</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">indepVarList</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">depVarList</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inboth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">The following parameters(s) are used as both dependent and independent variables in Equivalence relations:</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inboth</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot;, &quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multdepVarList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">The following parameters(s) are used in multiple Equivalence relations as dependent variables:</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">multdepVarList</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">s</span><span class="o">+=</span> <span class="s">&quot;, &quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>            
        <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">equivVarList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indepVarList</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">depVarList</span><span class="p">)))</span>
    <span class="c">#print &#39;equivVarList&#39;,equivVarList</span>
<span class="c">#    inboth = set(fixedVarList).intersection(set(equivVarList))</span>
<span class="c">#    if len(inboth) &gt; 0:</span>
<span class="c">#        msg += &quot;\nError! The following variables are used in both Equivalence and Fixed constraints:\n&quot;</span>
<span class="c">#        s = &#39;&#39;</span>
<span class="c">#        for var in sorted(inboth):</span>
<span class="c">#            if s != &quot;&quot;: s+= &quot;, &quot;</span>
<span class="c">#            s += str(var)</span>
<span class="c">#        msg += &#39;\t&#39;+ s + &#39;\n&#39;</span>
<span class="c">#</span>
    <span class="c"># scan through parameters in each relationship. Are all varied? If only some are</span>
    <span class="c"># varied, create an error message. </span>
    <span class="c"># If all are varied and this is a constraint equation, then set VaryFree flag</span>
    <span class="c"># so that newly created relationships will be varied</span>
    <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">varlist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">VaryFree</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
            <span class="n">varied</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">notvaried</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                    <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                    <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">var</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fixedVarList</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Error: parameter &#39;</span><span class="o">+</span><span class="n">var</span><span class="o">+</span><span class="s">&quot; is Fixed and used in a constraint:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="c">#                if var in equivVarList:</span>
<span class="c">#                    msg += &#39;\nError: parameter &#39;+var+&quot; is Equivalenced and used in a constraint:\n\t&quot;</span>
<span class="c">#                    msg += _FormatConstraint(constrDict[rel],fixedList[rel])+&quot;\n&quot;</span>
            <span class="k">if</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">varied</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">]):</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Not all variables refined in constraint:</span><span class="se">\n\t</span><span class="s">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="n">_FormatConstraint</span><span class="p">(</span><span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">],</span><span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">])</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Not refined: &#39;</span> <span class="o">+</span> <span class="n">notvaried</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="k">if</span> <span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">VaryFree</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c"># if there were errors found, go no farther</span>
    <span class="k">if</span> <span class="n">msg</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39; *** ERROR in constraint definitions! ***&#39;</span>
        <span class="k">print</span> <span class="n">msg</span>
        <span class="k">raise</span> <span class="ne">Exception</span>
                
    <span class="c"># now process each group and create the relations that are needed to form</span>
    <span class="c"># non-singular square matrix</span>
    <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">varlist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">):</span> <span class="c"># too many relationships -- no can do</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;too many relationships&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">_FillArray</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">varlist</span><span class="p">)</span>
            <span class="n">_RowEchelon</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span><span class="n">arr</span><span class="p">,</span><span class="n">varlist</span><span class="p">)</span>
            <span class="n">constrArr</span> <span class="o">=</span> <span class="n">_FillArray</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">varlist</span><span class="p">,</span><span class="n">FillDiagonals</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">GramSchmidtOrtho</span><span class="p">(</span><span class="n">constrArr</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Singular relationships&#39;</span>

        <span class="n">mapvar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="p">[:]</span>
        <span class="c"># scan through all generated and input variables, add to the varied list</span>
        <span class="c"># all the new parameters where VaryFree has been set or where all the</span>
        <span class="c"># dependent parameters are varied. Check again for inconsistent variable use</span>
        <span class="c"># for new variables -- where varied and unvaried parameters get grouped</span>
        <span class="c"># together. I don&#39;t think this can happen when not flagged before, but</span>
        <span class="c"># it does not hurt to check again. </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)):</span>
            <span class="n">varied</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">notvaried</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">fixedval</span> <span class="o">=</span> <span class="n">fixedList</span><span class="p">[</span><span class="n">rel</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">constrDict</span><span class="p">[</span><span class="n">rel</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
                        <span class="n">varied</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">notvaried</span><span class="p">:</span> <span class="n">notvaried</span> <span class="o">+=</span> <span class="s">&#39;, &#39;</span>
                        <span class="n">notvaried</span> <span class="o">+=</span> <span class="n">var</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixedval</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">fixedval</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="n">paramPrefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">consNum</span><span class="p">)</span>
                <span class="n">mapvar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
                <span class="n">consNum</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">VaryFree</span> <span class="ow">or</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">varyList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mapvar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fixedval</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">varied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">notvaried</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Not all variables refined in generated constraint</span><span class="se">\n\t</span><span class="s">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Not refined: &#39;</span> <span class="o">+</span> <span class="n">notvaried</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">dependentParmList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span>
        <span class="n">arrayList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constrArr</span><span class="p">)</span>
        <span class="n">invarrayList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">constrArr</span><span class="p">))</span>
        <span class="n">indParmList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapvar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">msg</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39; *** ERROR in constraint definitions! ***&#39;</span>
        <span class="k">print</span> <span class="n">msg</span>
        <span class="k">print</span> <span class="n">VarRemapShow</span><span class="p">(</span><span class="n">varyList</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span>
    <span class="c"># setup dictionary containing the fixed values</span>
    <span class="k">global</span> <span class="n">fixedDict</span> 
    <span class="c"># key is original ascii string, value is float</span>
    <span class="k">for</span> <span class="n">fixedval</span> <span class="ow">in</span> <span class="n">fixedList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fixedval</span><span class="p">:</span>
            <span class="n">fixedDict</span><span class="p">[</span><span class="n">fixedval</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fixedval</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="c"># on debug, show what is parsed &amp; generated, semi-readable</span>
        <span class="k">print</span> <span class="mi">50</span><span class="o">*</span><span class="s">&#39;-&#39;</span>
        <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">varlist</span><span class="p">,</span><span class="n">multarr</span><span class="p">,</span><span class="n">inv</span><span class="p">,</span><span class="n">mapvar</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">*** relation(s) in group:&#39;</span><span class="p">,</span><span class="n">group</span><span class="p">,</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">vars in group:&#39;</span><span class="p">,</span><span class="n">varlist</span>
            <span class="k">print</span> <span class="s">&#39;new parameters:&#39;</span><span class="p">,</span> <span class="n">mapvar</span>
            <span class="k">print</span> <span class="s">&#39;Input relationship matrix&#39;</span>
            <span class="k">print</span> <span class="n">multarr</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span>
            <span class="n">added</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">added</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;added relationship rows&#39;</span>
                <span class="k">print</span> <span class="n">multarr</span><span class="p">[</span><span class="n">added</span><span class="p">:]</span>
            <span class="k">print</span> <span class="s">&#39;Inverse relationship matrix&#39;</span>
            <span class="k">print</span> <span class="n">inv</span>
</div>
<div class="viewcode-block" id="StoreEquivalence"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.StoreEquivalence">[docs]</a><span class="k">def</span> <span class="nf">StoreEquivalence</span><span class="p">(</span><span class="n">independentVar</span><span class="p">,</span><span class="n">dependentList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Takes a list of dependent parameter(s) and stores their</span>
<span class="sd">    relationship to a single independent parameter (independentVar)</span>

<span class="sd">    :param str independentVar: name of master parameter that will be used to determine the value</span>
<span class="sd">      to set the dependent variables</span>

<span class="sd">    :param list dependentList: a list of parameters that will set from</span>
<span class="sd">         independentVar. Each item in the list can be a string with the parameter</span>
<span class="sd">         name or a tuple containing a name and multiplier:</span>
<span class="sd">         ``[&#39;parm1&#39;,(&#39;parm2&#39;,.5),]``</span>

<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span>
    <span class="n">mapList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">multlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dependentList</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">var</span><span class="p">,</span><span class="n">mult</span> <span class="o">=</span> <span class="n">var</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">,</span> <span class="s">&quot;Cannot parse &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; as var or (var,multiplier)&quot;</span>
        <span class="n">mapList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">multlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">mult</span><span class="p">,)))</span>
    <span class="c"># added relationships to stored values</span>
    <span class="n">arrayList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">invarrayList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">multlist</span><span class="p">))</span>
    <span class="n">indParmList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">independentVar</span><span class="p">,)))</span>
    <span class="n">dependentParmList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapList</span><span class="p">)</span>
    <span class="k">return</span>
</div>
<div class="viewcode-block" id="GetDependentVars"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.GetDependentVars">[docs]</a><span class="k">def</span> <span class="nf">GetDependentVars</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;Return a list of dependent variables: e.g. variables that are</span>
<span class="sd">    constrained in terms of other variables</span>

<span class="sd">    :returns: a list of variable names</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dependentVars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">global</span> <span class="n">dependentParmList</span>
    <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">dependentParmList</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">itm</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span> <span class="n">dependentVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">itm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dependentVars</span>
</div>
<div class="viewcode-block" id="GetIndependentVars"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.GetIndependentVars">[docs]</a><span class="k">def</span> <span class="nf">GetIndependentVars</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;Return a list of independent variables: e.g. variables that are</span>
<span class="sd">    created by constraints of other variables</span>

<span class="sd">    :returns: a list of variable names</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">independentVars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">global</span> <span class="n">indParmList</span><span class="p">,</span><span class="n">fixedDict</span>
    <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">indParmList</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fixedDict</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">independentVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">independentVars</span>
</div>
<div class="viewcode-block" id="PrintIndependentVars"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.PrintIndependentVars">[docs]</a><span class="k">def</span> <span class="nf">PrintIndependentVars</span><span class="p">(</span><span class="n">parmDict</span><span class="p">,</span><span class="n">varyList</span><span class="p">,</span><span class="n">sigDict</span><span class="p">,</span><span class="n">PrintAll</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">pFile</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Print the values and uncertainties on the independent variables&#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">fixedDict</span>
    <span class="n">printlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mapvars</span> <span class="o">=</span> <span class="n">GetIndependentVars</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapvars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fixedDict</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">PrintAll</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sigDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">printlist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">name</span><span class="p">,</span><span class="n">parmDict</span><span class="p">[</span><span class="n">name</span><span class="p">],</span><span class="n">sig</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">printlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">pFile</span><span class="p">,</span><span class="mi">130</span><span class="o">*</span><span class="s">&#39;-&#39;</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">pFile</span><span class="p">,</span><span class="s">&quot;Variables generated by constraints&quot;</span>
    <span class="n">printlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">[</span><span class="bp">None</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">esd</span> <span class="ow">in</span> <span class="n">printlist</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">120</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">pFile</span><span class="p">,</span><span class="s">&#39;&#39;</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">pFile</span><span class="p">,</span><span class="n">s1</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">pFile</span><span class="p">,</span><span class="n">s2</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">pFile</span><span class="p">,</span><span class="n">s3</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">if</span> <span class="n">s1</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="s">&#39; name  :&#39;</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="s">&#39; value :&#39;</span>
            <span class="n">s3</span> <span class="o">=</span> <span class="s">&#39; sig   :&#39;</span>
        <span class="n">s1</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="si">%15s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="si">%15.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">esd</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">s3</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="si">%15s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39;n/a&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>    
            <span class="n">s3</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="si">%15.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">esd</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ComputeDepESD"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.ComputeDepESD">[docs]</a><span class="k">def</span> <span class="nf">ComputeDepESD</span><span class="p">(</span><span class="n">covMatrix</span><span class="p">,</span><span class="n">varyList</span><span class="p">,</span><span class="n">parmDict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute uncertainties for dependent parameters from independent ones</span>
<span class="sd">    returns a dictionary containing the esd values for dependent parameters</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sigmaDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">invmultarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">):</span>
        <span class="c">#if invmultarr is None: continue # probably not needed</span>
        <span class="n">valuelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">parmDict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">mapvars</span><span class="p">]</span>
        <span class="c"># get the v-covar matrix for independent parameters </span>
        <span class="n">vcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">mapvars</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">mapvars</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span><span class="n">name1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapvars</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">iv1</span> <span class="o">=</span> <span class="n">varyList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i2</span><span class="p">,</span><span class="n">name2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapvars</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">iv2</span> <span class="o">=</span> <span class="n">varyList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name2</span><span class="p">)</span>
                <span class="n">vcov</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">covMatrix</span><span class="p">[</span><span class="n">iv1</span><span class="p">][</span><span class="n">iv2</span><span class="p">]</span>
        <span class="c"># vec is the vector that multiplies each of the independent values</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">vec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span><span class="n">invmultarr</span><span class="p">):</span>
            <span class="n">sigmaDict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">vcov</span><span class="p">,</span><span class="n">vec</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">sigmaDict</span>
</div>
<span class="k">def</span> <span class="nf">_FormatConstraint</span><span class="p">(</span><span class="n">RelDict</span><span class="p">,</span><span class="n">RelVal</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Formats a Constraint or Function for use in a convenient way&#39;&#39;&#39;</span>
    <span class="n">linelen</span> <span class="o">=</span> <span class="mi">45</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">var</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">RelDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">linelen</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39; + &#39;</span>
        <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39; - &#39;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="si">%.3f</span><span class="s">*</span><span class="si">%s</span><span class="s"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">var</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">linelen</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">RelVal</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39; = New variable&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39; = &#39;</span> <span class="o">+</span> <span class="n">RelVal</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s1</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span> <span class="n">s1</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n\t</span><span class="s">&#39;</span>
        <span class="n">s1</span> <span class="o">+=</span> <span class="n">s2</span>
    <span class="k">return</span> <span class="n">s1</span>

<div class="viewcode-block" id="VarRemapShow"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.VarRemapShow">[docs]</a><span class="k">def</span> <span class="nf">VarRemapShow</span><span class="p">(</span><span class="n">varyList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;List out the saved relationships. This should be done after the constraints have been</span>
<span class="sd">    defined using :func:`StoreEquivalence`, :func:`GroupConstraints` and :func:`GenerateConstraints`.</span>

<span class="sd">    :returns: a string containing the details of the contraint relationships</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixedVarList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;Fixed Variables:</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixedVarList</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;    &#39;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;Variable mapping relations:</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">fixedDict</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">multarr</span><span class="p">,</span><span class="n">invmultarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">mv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapvars</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">multarr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; is equivalent to parameter(s): &#39;</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span><span class="n">invmultarr</span><span class="p">):</span>
                    <span class="c">#print v,m[0]</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  &amp; &#39;</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot; / &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>                        
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="k">continue</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s"> = &#39;</span> <span class="o">%</span> <span class="n">mv</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multarr</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">varlist</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39; + &#39;</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s"> * </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39; VARY&#39;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;Inverse variable mapping relations:</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">invmultarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">mv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">varlist</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s"> = &#39;</span> <span class="o">%</span> <span class="n">mv</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">invmultarr</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">mapvars</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39; + &#39;</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s"> * </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">return</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="Dict2Deriv"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.Dict2Deriv">[docs]</a><span class="k">def</span> <span class="nf">Dict2Deriv</span><span class="p">(</span><span class="n">varyList</span><span class="p">,</span><span class="n">derivDict</span><span class="p">,</span><span class="n">dMdv</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute derivatives for Independent Parameters from the</span>
<span class="sd">    derivatives for the original parameters</span>

<span class="sd">    :param list varyList: a list of parameters names that will be varied</span>

<span class="sd">    :param dict derivDict: a dict containing derivatives for parameter values keyed by the</span>
<span class="sd">      parameter names.</span>

<span class="sd">    :param list dMdv: a Jacobian, as a list of np.array containing derivatives for dependent</span>
<span class="sd">      parameter computed from derivDict</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">invarrayList</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">multarr</span><span class="p">,</span><span class="n">invmultarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapvars</span><span class="p">):</span>
            <span class="c"># grouped variables: need to add in the derv. w/r</span>
            <span class="c"># dependent variables to the independent ones</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">varyList</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># skip if independent var not varied</span>
            <span class="k">if</span> <span class="n">multarr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span><span class="n">invmultarr</span><span class="p">):</span>
                    <span class="c">#print &#39;add derv&#39;,v,&#39;/&#39;,m[0],&#39;to derv&#39;,name</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="n">dMdv</span><span class="p">[</span><span class="n">varyList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">derivDict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span><span class="n">multarr</span><span class="p">[</span><span class="n">i</span><span class="p">,:]):</span>
                    <span class="c">#print &#39;add derv&#39;,v,&#39;*&#39;,m,&#39;to derv&#39;,name</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="n">dMdv</span><span class="p">[</span><span class="n">varyList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">derivDict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Map2Dict"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.Map2Dict">[docs]</a><span class="k">def</span> <span class="nf">Map2Dict</span><span class="p">(</span><span class="n">parmDict</span><span class="p">,</span><span class="n">varyList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create (or update) the Independent Parameters from the original</span>
<span class="sd">    set of Parameters</span>

<span class="sd">    Removes dependent variables from the varyList</span>

<span class="sd">    This should be done once, after the constraints have been</span>
<span class="sd">    defined using :func:`StoreEquivalence`,</span>
<span class="sd">    :func:`GroupConstraints` and :func:`GenerateConstraints` and</span>
<span class="sd">    before any variable refinement is done</span>
<span class="sd">    to complete the parameter dictionary by defining independent</span>
<span class="sd">    parameters and satisfying the constraint equations. </span>

<span class="sd">    :param dict parmDict: a dict containing parameter values keyed by the</span>
<span class="sd">      parameter names.</span>
<span class="sd">      This will contain updated values for both dependent and independent</span>
<span class="sd">      parameters after Dict2Map is called. It will also contain some</span>
<span class="sd">      unexpected entries of every constant value {&#39;0&#39;:0.0} &amp; {&#39;1.0&#39;:1.0},</span>
<span class="sd">      which do not cause any problems. </span>

<span class="sd">    :param list varyList: a list of parameters names that will be varied</span>
<span class="sd">    </span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c"># process the Independent vars: remove dependent ones from varylist</span>
    <span class="c"># and then compute values for the Independent ones from their dependents</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">fixedDict</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">multarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">varlist</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">varyList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">multarr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">valuelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">parmDict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">varlist</span><span class="p">]</span>
        <span class="n">parmDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mapvars</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">multarr</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">valuelist</span><span class="p">)))</span>
                        <span class="p">)</span>
    <span class="c"># now remove fixed variables from the varyList</span>
    <span class="k">global</span> <span class="n">fixedVarList</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">fixedVarList</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">varyList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="c"># Set constrained parameters to their fixed values</span>
    <span class="n">parmDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fixedDict</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Dict2Map"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.Dict2Map">[docs]</a><span class="k">def</span> <span class="nf">Dict2Map</span><span class="p">(</span><span class="n">parmDict</span><span class="p">,</span><span class="n">varyList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Applies the constraints defined using :func:`StoreEquivalence`,</span>
<span class="sd">    :func:`GroupConstraints` and :func:`GenerateConstraints` by changing</span>
<span class="sd">    values in a dict containing the parameters. This should be</span>
<span class="sd">    done before the parameters are used for any computations</span>

<span class="sd">    :param dict parmDict: a dict containing parameter values keyed by the</span>
<span class="sd">      parameter names.</span>
<span class="sd">      This will contain updated values for both dependent and independent</span>
<span class="sd">      parameters after Dict2Map is called. It will also contain some</span>
<span class="sd">      unexpected entries of every constant value {&#39;0&#39;:0.0} &amp; {&#39;1.0&#39;:1.0},</span>
<span class="sd">      which do not cause any problems. </span>

<span class="sd">    :param list varyList: a list of parameters names that will be varied</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">dependentParmList</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">fixedDict</span>
    <span class="c"># reset fixed values (should not be needed, but very quick) </span>
    <span class="c"># - this seems to update parmDict with {&#39;0&#39;:0.0} &amp; {&#39;1.0&#39;:1.0} - probably not what was intended</span>
    <span class="c"># not needed, but also not a problem - BHT</span>
    <span class="n">parmDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fixedDict</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">varlist</span><span class="p">,</span><span class="n">mapvars</span><span class="p">,</span><span class="n">invmultarr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dependentParmList</span><span class="p">,</span><span class="n">indParmList</span><span class="p">,</span><span class="n">invarrayList</span><span class="p">):</span>
        <span class="c">#if invmultarr is None: continue</span>
        <span class="n">valuelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">parmDict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">mapvars</span><span class="p">]</span>
        <span class="n">parmDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invmultarr</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">valuelist</span><span class="p">)))</span>
                        <span class="p">)</span>

<span class="c">#======================================================================</span>
<span class="c"># internal routines follow (these routines are unlikely to be called</span>
<span class="c"># from outside the module)</span>
</div>
<div class="viewcode-block" id="GramSchmidtOrtho"><a class="viewcode-back" href="../GSASIImapvars.html#GSASIImapvars.GramSchmidtOrtho">[docs]</a><span class="k">def</span> <span class="nf">GramSchmidtOrtho</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">nkeep</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Use the Gram-Schmidt process (http://en.wikipedia.org/wiki/Gram-Schmidt) to</span>
<span class="sd">    find orthonormal unit vectors relative to first row.</span>

<span class="sd">    If nkeep is non-zero, the first nkeep rows in the array are not changed</span>
<span class="sd">    </span>
<span class="sd">    input: </span>
<span class="sd">       arrayin: a 2-D non-singular square array</span>
<span class="sd">    returns:</span>
<span class="sd">       a orthonormal set of unit vectors as a square array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">proj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="s">&#39;Projection operator&#39;</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nkeep</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">proj</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span><span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">,</span><span class="s">&quot;Singular input to GramSchmidtOrtho&quot;</span>
        <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">a</span>
</div>
<span class="k">def</span> <span class="nf">_FillArray</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span><span class="nb">dict</span><span class="p">,</span><span class="n">collist</span><span class="p">,</span><span class="n">FillDiagonals</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Construct a n by n matrix (n = len(collist)</span>
<span class="sd">    filling in the rows using the relationships defined</span>
<span class="sd">    in the dictionaries selected by sel</span>

<span class="sd">    If FillDiagonals is True, diagonal elements in the</span>
<span class="sd">    array are set to 1.0</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">collist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">FillDiagonals</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">[</span><span class="n">n</span><span class="p">,])</span>
    <span class="c"># fill the top rows</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cnum</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sel</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">collist</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="n">cnum</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span> <span class="nf">_SwapColumns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Swap columns in matrix m as well as the labels in v </span>
<span class="sd">    so that element (i,i) is replaced by the first non-zero element in row i after that element</span>

<span class="sd">    Throws an exception if there are no non-zero elements in that row</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">m</span><span class="p">[:,(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[:,(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)]</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">,</span><span class="s">&#39;Singular input&#39;</span>

<span class="k">def</span> <span class="nf">_RowEchelon</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">collist</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert the first m rows in Matrix arr to row-echelon form</span>
<span class="sd">    exchanging columns in the matrix and collist as needed.</span>

<span class="sd">    throws an exception if the matrix is singular because</span>
<span class="sd">    the first m rows are not linearly independent</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">collist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">_SwapColumns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">collist</span><span class="p">)</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">/=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="c"># normalize row</span>
        <span class="c"># subtract current row from subsequent rows to set values to left of diagonal to 0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">-=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parmdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">constrDict</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="s">&#39;0:12:Scale&#39;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s">&#39;0:11:Scale&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;0:14:Scale&#39;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="s">&#39;0:13:Scale&#39;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="s">&#39;0:0:Scale&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#39;0:0:eA&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#39;2::C(10,6,1)&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;1::C(10,6,1)&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#39;1::C(10,0,1)&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;2::C(10,0,1)&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#39;1::AUiso:0&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;0::AUiso:0&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#39;0::A0&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
        <span class="p">]</span>
    <span class="n">fixedList</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;5.0&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;1.0&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">]</span>
    <span class="n">StoreEquivalence</span><span class="p">(</span><span class="s">&#39;2::atomx:3&#39;</span><span class="p">,(</span><span class="s">&#39;2::atomy:3&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;2::atomz:3&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,),</span> <span class="p">))</span>
    <span class="c">#StoreEquivalence(&#39;1::atomx:3&#39;,(&#39;2::atomx:3&#39;, (&#39;2::atomz:3&#39;,2,), )) # error: dependent &amp; independent vars mixed</span>
    <span class="c">#StoreEquivalence(&#39;1::atomx:3&#39;,(&#39;2::atomy:3&#39;, (&#39;2::atomz:3&#39;,2,), )) # error: dependent vars repeated</span>
    <span class="c">#StoreEquivalence(&#39;0:1:eA&#39;,(&#39;0:0:eA&#39;,)) # error: equiv &amp; fixed</span>
    <span class="c">#StoreEquivalence(&#39;0:99:Scale&#39;,(&#39;0:12:Scale&#39;,)) # error: equiv &amp; constrained</span>
    <span class="c">#StoreEquivalence(&#39;0:12:Scale&#39;,(&#39;0:99:Scale&#39;,)) # error: equiv &amp; constrained</span>
    <span class="n">varylist</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;2::atomx:3&#39;</span><span class="p">,</span>
                <span class="s">&#39;2::C(10,6,1)&#39;</span><span class="p">,</span> <span class="s">&#39;1::C(10,6,1)&#39;</span><span class="p">,</span>
                <span class="s">&#39;2::atomy:3&#39;</span><span class="p">,</span> <span class="s">&#39;2::atomz:3&#39;</span><span class="p">,</span>
                <span class="s">&#39;0:12:Scale&#39;</span><span class="p">,</span> <span class="s">&#39;0:11:Scale&#39;</span><span class="p">,</span> <span class="s">&#39;0:14:Scale&#39;</span><span class="p">,</span> <span class="s">&#39;0:13:Scale&#39;</span><span class="p">,</span> <span class="s">&#39;0:0:Scale&#39;</span><span class="p">]</span>
<span class="c">#    e,w = CheckConstraints([,</span>
<span class="c">#                     [{&#39;2:0:Scale&#39;: 1.0, &#39;5:0:Scale&#39;: 1.0, &#39;10:0:Scale&#39;: 1.0, &#39;6:0:Scale&#39;: 1.0, &#39;9:0:Scale&#39;: 1.0, &#39;8:0:Scale&#39;: 1.0,# &#39;3:0:Scale&#39;: 1.0, &#39;4:0:Scale&#39;: 1.0, &#39;7:0:Scale&#39;: 1.0, &#39;1:0:Scale&#39;: 1.0, &#39;0:0:Scale&#39;: 1.0}],</span>
<span class="c">#                     [&#39;1.0&#39;])</span>
<span class="c">#    if e: print &#39;error=&#39;,e</span>
<span class="c">#    if w: print &#39;error=&#39;,w</span>
<span class="c">#    varyList = [&#39;0::A0&#39;, &#39;0::AUiso:0&#39;, &#39;0::Afrac:1&#39;, &#39;0::Afrac:2&#39;, &#39;0::Afrac:3&#39;, &#39;0::Afrac:4&#39;, &#39;0::dAx:5&#39;, &#39;0::dAy:5&#39;, &#39;0::dAz:5&#39;, &#39;0::AUiso:5&#39;, &#39;:0:Back:0&#39;, &#39;:0:Back:1&#39;, &#39;:0:Back:2&#39;, &#39;:0:Back:3&#39;, &#39;:0:Back:4&#39;, &#39;:0:Back:5&#39;, &#39;:0:Back:6&#39;, &#39;:0:Back:7&#39;, &#39;:0:Back:8&#39;, &#39;:0:Back:9&#39;, &#39;:0:Back:10&#39;, &#39;:0:Back:11&#39;, &#39;:0:U&#39;, &#39;:0:V&#39;, &#39;:0:W&#39;, &#39;:0:X&#39;, &#39;:0:Y&#39;, &#39;:0:Scale&#39;, &#39;:0:DisplaceX&#39;, &#39;:0:DisplaceY&#39;]</span>
<span class="c">#    constrDict = [</span>
<span class="c">#        {&#39;0::Afrac:4&#39;: 24.0, &#39;0::Afrac:1&#39;: 16.0, &#39;0::Afrac:3&#39;: 24.0, &#39;0::Afrac:2&#39;: 16.0},</span>
<span class="c">#        {&#39;0::Afrac:1&#39;: 1.0, &#39;0::Afrac:2&#39;: 1.0},</span>
<span class="c">#        {&#39;0::Afrac:4&#39;: 1.0, &#39;0::Afrac:3&#39;: 1.0}]</span>
<span class="c">#    fixedList = [&#39;40.0&#39;, &#39;1.0&#39;, &#39;1.0&#39;]</span>

    <span class="n">errmsg</span><span class="p">,</span> <span class="n">warnmsg</span> <span class="o">=</span> <span class="n">CheckConstraints</span><span class="p">(</span><span class="n">varylist</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">fixedList</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">errmsg</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;*** Error ********************&quot;</span>
        <span class="k">print</span> <span class="n">errmsg</span>
    <span class="k">if</span> <span class="n">warnmsg</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;*** Warning ********************&quot;</span>
        <span class="k">print</span> <span class="n">warnmsg</span>
    <span class="k">if</span> <span class="n">errmsg</span> <span class="ow">or</span> <span class="n">warnmsg</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span> <span class="o">=</span> <span class="n">GroupConstraints</span><span class="p">(</span><span class="n">constrDict</span><span class="p">)</span>
    <span class="n">GenerateConstraints</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span><span class="n">parmlist</span><span class="p">,</span><span class="n">varylist</span><span class="p">,</span><span class="n">constrDict</span><span class="p">,</span><span class="n">fixedList</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">VarRemapShow</span><span class="p">(</span><span class="n">varylist</span><span class="p">)</span>
    <span class="n">parmdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span>
        <span class="s">&#39;0:12:Scale&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;0:11:Scale&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;0:14:Scale&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;0:13:Scale&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&#39;0:0:Scale&#39;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="s">&#39;0:0:eA&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="s">&#39;2::C(10,6,1)&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s">&#39;1::C(10,6,1)&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="s">&#39;1::C(10,0,1)&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s">&#39;2::C(10,0,1)&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="s">&#39;1::AUiso:0&#39;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span> <span class="s">&#39;0::AUiso:0&#39;</span><span class="p">:</span> <span class="mf">0.03</span><span class="p">,</span>
        <span class="s">&#39;0::A0&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="s">&#39;2::atomx:3&#39;</span><span class="p">:</span><span class="mf">0.23</span><span class="p">,</span><span class="s">&#39;2::atomy:3&#39;</span><span class="p">:</span><span class="o">-.</span><span class="mi">23</span><span class="p">,</span> <span class="s">&#39;2::atomz:3&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.11</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="k">print</span> <span class="s">&#39;parmdict start&#39;</span><span class="p">,</span><span class="n">parmdict</span>
    <span class="k">print</span> <span class="s">&#39;varylist start&#39;</span><span class="p">,</span><span class="n">varylist</span>
    <span class="n">before</span> <span class="o">=</span> <span class="n">parmdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Map2Dict</span><span class="p">(</span><span class="n">parmdict</span><span class="p">,</span><span class="n">varylist</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;parmdict before and after Map2Dict&#39;</span>
    <span class="k">print</span> <span class="s">&#39;  key / before / after&#39;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parmdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">print</span> <span class="s">&#39;  &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">,</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span><span class="n">before</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span><span class="n">parmdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&#39;varylist after&#39;</span><span class="p">,</span><span class="n">varylist</span>
    <span class="n">before</span> <span class="o">=</span> <span class="n">parmdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Dict2Map</span><span class="p">(</span><span class="n">parmdict</span><span class="p">,</span><span class="n">varylist</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;after Dict2Map&#39;</span>
    <span class="k">print</span> <span class="s">&#39;  key / before / after&#39;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parmdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">print</span> <span class="s">&#39;  &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">,</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span><span class="n">before</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span><span class="n">parmdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="c">#    dMdv = len(varylist)*[0]</span>
<span class="c">#    deriv = {}</span>
<span class="c">#    for i,v in enumerate(parmdict.keys()): deriv[v]=i</span>
<span class="c">#    Dict2Deriv(varylist,deriv,dMdv)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/G2_html_logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">GSAS-II 0.2.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Von Dreele and Toby for Argonne National Laboratory.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>